<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
  <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
  
  <title>PyOpenGL for OpenGL Programmers</title><link rel="stylesheet" type="text/css" href="tutorial.css">
  <meta name="author" content="Mike C. Fletcher"></head>

<body>
<h1>PyOpenGL for OpenGL Programmers<br>
</h1>
<p class="introduction">This document describes those features of
PyOpenGL which are likely to be unfamiliar to OpenGL programmers.
It also explains various features of PyOpenGL which are not covered in
general OpenGL documentation.<br>
</p>

<h2>Speed Concerns</h2><p>PyOpenGL 3.x is far slower than PyOpenGL 2.x,
and PyOpenGL 2.x was not fast. Out of the box PyOpenGL 3.x is
configured to be as helpful and robust as possible, both traits which
make the system much slower than it could be. PyOpenGL is now
implemented using ctypes, rather than SWIG, the flexibility of ctypes
has a significant cost in terms of performance. PyOpenGL 3.x is
also far more flexible with regard to data-types, that flexibility has
a noticeable performance cost. Throughout this document you will
see descriptions for how to trade off flexibility, helpfulness and
robustness in order to claw back speed.</p><p>If you are attempting to
do per-vertex operations (e.g. glColor, glNormal, glVertex) then you
will find that PyOpenGL 3.x is ridiculously slow. Luckily, all of
those features are now deprecated. For array-based geometry where
the arrays are large and in native-format-compatible formats,
PyOpenGL's overhead tends to be amortized over the size of the arrays
being processed.</p><h2>Method Signatures vs. C OpenGL<br>
</h2>
<p>Most of the functions which appear in PyOpenGL 3 are identical in
calling method and functionality to that of the appropriate C
specification. There are a few exceptions because of the
differences between C and Python. Most of these exceptions are due to
the difference between C and Python in the way that they access
arrays. For example, a C function like this:</p>
<pre>void foo(int count, const int *args);</pre>
<p>will have the Python binding:</p>
<pre>foo(args) -&gt; None</pre>
<p>Also C functions which write array data to a function argument like:</p>
<pre>void bar(int args[4]);</pre>
<p>will normally have the Python binding:</p>
<pre>bar() -&gt; args[]</pre>
<p>The following sections will document changes other than simple
changes like the above examples.<br>
</p>
<h2>Errors raise Exceptions</h2>
<p>PyOpenGL generally uses "strict" OpenGL operation, which is closer to
the operation of Python itself, i.e. errors are raised as exceptions,
rather than requiring the user to check return values and/or call glCheckError manually.</p><p>You
can disable PyOpenGL's error checking by setting a module-level flag in
the OpenGL package before importing any of the sub-modules, like so:</p><pre>import OpenGL<br>OpenGL.ERROR_CHECKING = False<br>from OpenGL.GL import *<br>from OpenGL.GLU import *<br>...</pre>
<p>This will tend to cause a huge speed increase in your code, as the
number of OpenGL calls issued will roughly halve compared to the
error-checking version of the same script. You will normally want
to develop with error-checking on and only switch it off for
production/release code.</p><p>The exceptions normally raised by PyOpenGL are:<br>
</p>
<ul>
  <li>GL.GLerror by all modules except WGL</li>
  <li>GLU.GLUerror by some GLU functions. Note that GLU can also throw
GL.GLerror</li>
  <li>WindowsError/SystemError by WGL</li><li>General TypeError/ValueError errors for e.g. wrong-datatype problems</li>
</ul>
<p>GL.GLerror is a subclass of GL.Error and has a large amount of extra information regarding the call wrapping process:</p><ul><li>err -- OpenGL error code</li><li>result -- OpenGL result-code for the operation</li><li>baseOperation -- the base OpenGL function being called</li><li>pyArgs -- the set of top-level arguments passed to the function</li><li>cArgs -- the set of Python-level objects expanded from pyArgs</li><li>cArguments -- the set of C-level objects converted from cArgs</li><li>description -- textual OpenGL description of the error (normally pretty terse, useful primarily to look at the documentation)</li></ul>
<h2>Logging</h2><p>By default, PyOpenGL will log errors to the Python
logging module. You can disable this by setting a flag before
importing the OpenGL sub-modules:</p><pre>import OpenGL<br>OpenGL.ERROR_LOGGING = False<br>from OpenGL.GL import *<br>...<br></pre><p>which will provide a performance improvement for non-development code.</p><p>Conversely,
if you are finding that your code is crashing and you need to trace
through the operation of PyOpenGL then it is possible to instruct
PyOpenGL to trace the calls to OpenGL to the logging module:</p><pre>import OpenGL<br>OpenGL.FULL_LOGGING = True<br>from OpenGL.GL import *<br>...<br></pre><p>this is extremely slow, but often useful during the debugging process.</p><h2>Wrapped Operations<br></h2><p>Wrapped Python arguments may go through a number of possible wrapper
operations in order to produce a final call from the Python
argument-set:</p><ul><li>takes a set of args and passes a set of converters over them to convert them to acceptable object types (pyArgs)</li><li>runs
a set of cConverters over pyArgs to produce a set of cArgs,
representing the Pythonic objects which map 1:1 to the C arguments
(cArgs), this will often expand arguments from a single Python argument
to mulitple C argument objects</li><li>runs a set of cResolvers over cArgs to produce a set of final ctypes-compatible arguments (cArguments)</li><li>runs
a set of storeValues converters to save any temporary objects which
need to remain in-memory to prevent memory-access failures for later
calls (e.g. references to pointers require that the object holding the
memory remain in-memory)</li><li>runs a function to choose what value to return from the function</li></ul><p>These
operations are implemented by the OpenGL.wrapper.Wrapper class, which
is the focus of most of theOpenGL_accelerate module's optimizations
(for obvious reasons).</p><h2>Array Handling</h2>

<p>PyOpenGL 3.x supports a significant range of array-compatible data-types, among the default plug-ins are:</p><ul><li>numpy arrays</li><li>Python strings (byte-strings)</li><li>numbers (acting as pointers-to-single-value arrays)</li><li>ctypes arrays</li><li>ctypes parameters</li><li>ctypes pointers</li><li>lists/tuples</li><li>vertex buffer objects</li></ul><p>when
a PyOpenGL 3.x entry point requires an "array" data-type (or a void*
data-type), it will use the PyOpenGL FormatHandler plugins
(OpenGL.arrays.formathandler) to decide how to convert the array to a
format compatible with the low-level OpenGL APIs.</p><p>Certain
format-types may allow for use as array types while not actually
containing a compatible copy of the data. Python lists, tuples
and numbers all require the creation of a temporary variable to hold
their data. As such you generally should not use them for
performance-critical operations. Similarly, if you pass a numpy
array with an incompatible data-type the wrapper may have to copy the
data in order to pass it into the C-level functions. For numpy
arrays, where the behavior is fast enough that you might not realize
it, but can negatively impact your performance, you can prevent this
behaviour by setting a flag in the OpenGL package before importing any
of the OpenGL modules:</p><pre>import OpenGL<br>OpenGL.ERROR_ON_COPY = True<br>from OpenGL.GL import *<br></pre><p>which will cause the numpy format handler to raise errors if it finds itself copying an array to another data-type.</p><p class="technical">Keep in mind that with OpenGL 3.1 it will become required that all non-index arrays be managed as Vertex Buffer Objects.</p><h3>Type-Specialized Array Functions</h3><p>Each call which sets an array pointer, such as glVertexPointer, may
have many variants. First there will a function which is identical that
of the specification. For the pointer argument one should pass a string.
Also note that the stride values are used.</p><p>Next there will a set of functions named:</p>
<pre>glXPointer{ub|b|us|s|ui|i|f|d}</pre>
<p>These will usually take as a single argument a multidimensional
array of values. The type argument is controlled by the suffix of the
function (ub is unsigned byte, b is byte, f is float, d is double etc.)
Most other arguments are derived from the dimensions of the array.</p>
<p>So for glColorPointer we have:</p>
<pre>glColorPointer(size, type, stride, pointer) -&gt; None<br>glColorPointerub(pointer[][]) -&gt; None<br>glColorPointerb(pointer[][]) -&gt; None<br>glColorPointerus(pointer[][]) -&gt; None<br>glColorPointers(pointer[][]) -&gt; None<br>glColorPointerui(pointer[][]) -&gt; None<br>glColorPointeri(pointer[][]) -&gt; None<br>glColorPointerf(pointer[][]) -&gt; None<br>glColorPointerd(pointer[][]) -&gt; None</pre>
<p>This same decoration strategy is used for other array functions
besides glXPointer.</p>
<p>For instance, glDrawElements has the Python binding:</p>
<pre>glDrawElements(mode, count, type, indices) -&gt; None</pre>
<p>where indices is expected to be a string. There are also the
decorated bindings:</p>
<pre>glDrawElementsub(mode, indices[]) -&gt; None<br>glDrawElementsus(mode, indices[]) -&gt; None<br>glDrawElementsui(mode, indices[]) -&gt; None</pre>
<p>where "indices" is now a single dimensional array.</p>
<p>When calling a glColorPointer, glVertexPointer, etc. Python needs to
allocate memory to store the values that OpenGL needs. This memory is
reference counted and takes into account function calls like
glPushClientAttrib and glPopClientAttrib. To force this memory to be
released one just need to make a call glColorPointerub(None).</p>
<p>Currently glPushClientAttrib will always set the
GL_CLIENT_VERTEX_ARRAY_BIT flag as glPopClientAttrib has no way of
knowing that flag was set and the state of the flag is needed to know
whether or not to decrement the pointer locks on the allocated memory.</p>
<p>This may change in the future. That said, surrounding array use
glPushClientAttrib/glPopClientAttrib is a good way to force the release
of any allocated memory, but make sure that all calls to glXPointer,
etc. are within the ClientAttrib block if you chose to use this scheme.</p>
<p class="technical">Note that since all the memory allocation is
automatic there is no need for glGetPointerv function, so it is excluded.</p>
<p class="technical">Note that the function glInterleavedArrays is also
present, but it does not have the variants that the others do (i.e., no
glInterleavedArraysf). glInterleavedArrays has been unofficially
deprecated for a long time, and is officially deprecated as of OpenGL
3.x</p><p class="technical">Note that for performance you may wish to use
the "raw" version of array-handling functions, as these often have less
processing applied than the "raw" version.
</p>
<h2>Image Routines</h2>
<p>glDrawPixels and the other image/texturing functions have much the
same decoration scheme as the array functions. For glDrawPixels there is
the standard function which expects a string as the pixel data:<br>
</p>
<pre>glDrawPixels(width, height, format, type, pixels) -&gt; None</pre>
<p>This function will respect the parameters set by glPixelStore{i|f}.</p>
<p>There is also a collection of variants which take a multidimensional
array as the data source and set glPixelStore{i|f} automatically. For
example:<br>
</p>
<pre>glDrawPixelsub(format, pixels) -&gt; None</pre>
<p>Notice that width and height are inferred from the pixel data and
the type is GLubyte.</p><p>PyOpenGL
sets up "normal" pixel-transfer mode when using imaging APIs, as almost
all Python image-aware modules/extensions assume, for instance, tightly
packed data-structures and would potentially cause access errors when
operating in standard OpenGL mode.<br>
</p>
<h2>Extensions and Conditional Functionality<br>
</h2>
<p>PyOpenGL has support for most OpenGL extensions. Extensions are
available as "normal" function pointers by importing the constructed
package name for the extension, for instance:</p><pre>from OpenGL.GL.ARB.vertex_buffer_object import *<br>buffer = glGenBuffersARB(1)</pre><p>there
is no need to call initialization functions or the like for the
extension module. You can, if you like, call the "init" function for
the extension to retrieve a boolean indicating whether the local
machine supports a given extension, like so:</p><pre>if glInitVertexBufferObjectARB():<br>	...<br></pre><p>However, it is normally clearer to test for the boolean truth of the entry points you wish to use:</p><pre>if (glGenBuffersARB):<br>	buffers = glGenBuffersARB( 1 )</pre><p>There
are often a number of entry points which implement the same API, for
which you would like to use whichever implementation is available
(likely with some preference in order). The OpenGL.extensions module
provides an easy mechanism to support this:</p><pre>from OpenGL.extensions import alternate<br>glCreateProgram = alternate( 'glCreateProgram', glCreateProgram, glCreateProgramObjectARB)<br>glCreateProgram = alternate( glCreateProgram, glCreateProgramObjectARB)</pre><p>If
the first element is a string it will be used as the name of the
alternate object, otherwise the name is taken from the first argument.</p><h2>Selection and Feedback Buffers<br>
</h2>
<p class="technical">Note that both selection and feedback buffers are
deprecated in OpenGL 3.x. You should be replacing
selection-buffer usage with either "unique color" selection rendering
or mathematical generated selection operations.</p><p>Normally in OpenGL to use a selection buffer one would do the
following:</p>
<pre>GLuint buffer[SIZE];<br>glSelectBuffer(SIZE, buffer);<br>glRenderMode(GL_SELECT);<br>/* draw some stuff */<br>GLint count = glRenderMode(GL_RENDER);<br>/* parse the selection buffer */</pre>

<p>In Python this accomplished like this:</p>
<pre>glSelectBuffer(SIZE) # allocate a selection buffer of SIZE elements<br>glRenderMode(GL_SELECT)<br># draw some stuff<br>buffer = glRenderMode(GL_RENDER)<br>for hit_record in buffer:<br>&nbsp;&nbsp;&nbsp; min_depth, max_depth, names = hit_record<br>&nbsp;&nbsp;&nbsp; # do something with the record</pre>
<p>Feedback buffers are used in the same way except that each item in
the buffer is tuple (token, value), where value is either a passthrough
token or a list of vertices.<br>
</p>
<p class="technical">Note that if glRenderMode returns a buffer then it
also <strong>resets OpenGL's pointer</strong> for the corresponding
buffer. This means that the buffer returned by glRenderMode is
independent of future calls to glRenderMode, i.e. it will not be
overwritten by any such future calls. This makes the returned buffer
somewhat thread-safe. It also means that <strong>every call to
glRenderMode(GL_SELECT | GL_FEEDBACK)</strong> needs to <strong>preceded
by a call to glSelectBuffer or glFeedbackBuffer</strong> first, i.e. the
following code <strong>will not work</strong>:</p>
<pre>### THIS DOESN'T WORK!!!<br>glSelectBuffer(SIZE) # allocate a selection buffer of SIZE elements<br>glRenderMode(GL_SELECT)<br># draw some stuff<br>buffer = glRenderMode(GL_RENDER)<br># do another selection<br>glRenderMode(GL_SELECT)<br># draw some stuff<br>buffer = glRenderMode(GL_RENDER)</pre>
<p class="technical">Instead one must do:<br>
</p>
<pre>glSelectBuffer(SIZE) # allocate a selection buffer of SIZE elements<br>glRenderMode(GL_SELECT)<br># draw some stuff<br>buffer = glRenderMode(GL_RENDER)<br># do another selection<br>glSelectBuffer(SIZE) allocate a new selection buffer<br>glRenderMode(GL_SELECT)<br># draw some stuff<br>buffer = glRenderMode(GL_RENDER)</pre><h2>Function Aliases</h2>
<p>PyOpenGL has historically provided a number of aliases for
functions.&nbsp; For backwards compatibility, these aliases continue to
be provided:<br>
</p>
<ul>
  <li>glGetBooleanv aliases</li>
  <ul>
    <li>glGetBoolean</li>
  </ul>
  <li>glGetDoublev aliases</li>
  <ul>
    <li>glGetDouble</li>
  </ul>
  <li>glGetIntegerv aliases</li>
  <ul>
    <li>glGetInteger</li>
  </ul>
  <li>glColord aliases</li>
  <ul>
    <li>glColor</li>
  </ul>
  <ul>
    <li>glColor3</li>
  </ul>
  <ul>
    <li>glColor4</li>
  </ul>
  <li>glEvalCoordd aliases</li>
  <ul>
    <li>glEvalCoord</li>
  </ul>
  <ul>
    <li>glEvalCoord1</li>
  </ul>
  <ul>
    <li>glEvalCoord2</li>
  </ul>
  <li>glFogfv aliases</li>
  <ul>
    <li>glFog</li>
  </ul>
  <li>glIndexd aliases</li>
  <ul>
    <li>glIndex</li>
  </ul>
  <li>glLightfv aliases</li>
  <ul>
    <li>glLight</li>
  </ul>
  <li>glLightModelfv aliases</li>
  <ul>
    <li>glLightModel</li>
  </ul>
  <li>glMaterialfv aliases</li>
  <ul>
    <li>glMaterial</li>
  </ul>
  <li>glNormald aliases</li>
  <ul>
    <li>glNormal</li>
  </ul>
  <ul>
    <li>glNormal3</li>
  </ul>
  <ul>
    <li>glNormal4</li>
  </ul>
  <li>glRasterPosd aliases</li>
  <ul>
    <li>glRasterPos</li>
  </ul>
  <ul>
    <li>glRasterPos2</li>
  </ul>
  <ul>
    <li>glRasterPos3</li>
    <li>glRasterPos4</li>
  </ul>
  <li>glRotated aliases</li>
  <ul>
    <li>glRotate</li>
  </ul>
  <li>glScaled aliases</li>
  <ul>
    <li>glScale</li>
  </ul>
  <li>glTexCoordd aliases</li>
  <ul>
    <li>glTexCoord</li>
    <li>glTexCoord1</li>
    <li>glTexCoord2</li>
    <li>glTexCoord3</li>
    <li>glTexCoord4</li>
  </ul>
  <li>glTexGendv aliases</li>
  <ul>
    <li>glTexGen</li>
  </ul>
  <li>glTexParameterfv aliases</li>
  <ul>
    <li>glTexParameter</li>
  </ul>
  <li>glTranslated aliases</li>
  <ul>
    <li>glTranslate</li>
  </ul>
  <li>glVertexd aliases</li>
  <ul>
    <li>glVertex</li>
  </ul>
</ul>
<p class="footer"><a href="index.html"><img src="../images/doc_logo_icon.gif" title="" alt="Documentation" style="border: 0px solid ; width: 32px; height: 32px;" align="middle"></a>&nbsp;<a href="http://pyopengl.sourceforge.net/"><img title="" alt="PyOpenGL" src="../images/icon2.jpg" style="border: 0px solid ; width: 32px; height: 32px;" align="middle"></a> A
SourceForge Open-Source project: <a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=5988&amp;type=1" style="border: 0px solid ; width: 88px; height: 31px;" alt="SourceForge" title="" align="middle"></a></p>
</body></html>
