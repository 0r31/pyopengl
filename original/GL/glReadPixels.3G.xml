<refentry id="glReadPixels.3G">
	<refmeta id="glReadPixels.3G-meta">
		<refentrytitle>glReadPixels</refentrytitle>
		<manvolnum>3G</manvolnum>
	</refmeta>
	<refnamediv id="glReadPixels.3G-name">
		<refname>glReadPixels</refname>
		<refpurpose>read a block of pixels from the frame buffer</refpurpose>
	</refnamediv>
	<refsynopsisdiv id="glReadPixels.3G-c_spec">
		<title>C Specification</title>
		<funcsynopsis>
			<funcprototype>
				<funcdef>void&nbsp;<function>glReadPixels</function></funcdef>
				<paramdef>GLint&nbsp;<parameter>x</parameter></paramdef>
				<paramdef>GLint&nbsp;<parameter>y</parameter></paramdef>
				<paramdef>GLsizei&nbsp;<parameter>width</parameter></paramdef>
				<paramdef>GLsizei&nbsp;<parameter>height</parameter></paramdef>
				<paramdef>GLenum&nbsp;<parameter>format</parameter></paramdef>
				<paramdef>GLenum&nbsp;<parameter>type</parameter></paramdef>
				<paramdef>GLvoid&nbsp;*<parameter>pixels</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
	</refsynopsisdiv>
	<refsect1 id="glReadPixels.3G-parameters">
		<title>Parameters</title>
		<variablelist>
			<varlistentry>
				<term><parameter>x</parameter>, <parameter>y</parameter></term>
				<listitem>
					<simpara>
						Specify the window coordinates of the first pixel that is read from the frame buffer. This location is the
						lower left corner of a rectangular block of pixels.
					</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><parameter>width</parameter>, <parameter>height</parameter></term>
				<listitem>
					<simpara>
						Specify the dimensions of the pixel rectangle. <parameter>width</parameter> and
						<parameter>height</parameter> of one correspond to a single pixel.
					</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><parameter>format</parameter></term>
				<listitem>
					<simpara>
						Specifies the of the pixel data. The following symbolic values are accepted:
						<constant>GL_COLOR_INDEX</constant>, <constant>GL_STENCIL_INDEX</constant>,
						<constant>GL_DEPTH_COMPONENT</constant>, <constant>GL_RED</constant>, <constant>GL_GREEN</constant>,
						<constant>GL_BLUE</constant>, <constant>GL_ALPHA</constant>, <constant>GL_RGB</constant>,
						<constant>GL_BGR</constant>, <constant>GL_RGBA</constant>, <constant>GL_BGRA</constant>,
						<constant>GL_LUMINANCE</constant>, and <constant>GL_LUMINANCE_ALPHA</constant>.
					</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><parameter>type</parameter></term>
				<listitem>
					<simpara>
						Specifies the data type of the pixel data. Must be one of <constant>GL_UNSIGNED_BYTE</constant>,
						<constant>GL_BYTE</constant>, <constant>GL_BITMAP</constant>, <constant>GL_UNSIGNED_SHORT</constant>,
						<constant>GL_SHORT</constant>, <constant>GL_UNSIGNED_INT</constant>, <constant>GL_INT</constant>,
						<constant>GL_FLOAT</constant>, <constant>GL_UNSIGNED_BYTE_3_3_2</constant>,
						<constant>GL_UNSIGNED_BYTE_2_3_3_REV</constant>, <constant>GL_UNSIGNED_SHORT_5_6_5</constant>,
						<constant>GL_UNSIGNED_SHORT_5_6_5_REV</constant>, <constant>GL_UNSIGNED_SHORT_4_4_4_4</constant>,
						<constant>GL_UNSIGNED_SHORT_4_4_4_4_REV</constant>, <constant>GL_UNSIGNED_SHORT_5_5_5_1</constant>,
						<constant>GL_UNSIGNED_SHORT_1_5_5_5_REV</constant>, <constant>GL_UNSIGNED_INT_8_8_8_8</constant>,
						<constant>GL_UNSIGNED_INT_8_8_8_8_REV</constant>, <constant>GL_UNSIGNED_INT_10_10_10_2</constant>, or
						<constant>GL_UNSIGNED_INT_2_10_10_10_REV</constant>.
					</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><parameter>pixels</parameter></term>
				<listitem>
					<simpara>
						Returns the pixel data.
					</simpara>
				</listitem>
			</varlistentry>
		</variablelist>
	</refsect1>
	<refsect1 id="glReadPixels.3G-description">
		<title>Description</title>
		<para>
			<function>glReadPixels</function> returns pixel data from the frame buffer, starting with the pixel whose lower left
			corner is at location (<parameter>x</parameter>, <parameter>y</parameter>), into client memory starting at location
			<parameter>pixels</parameter>. Several parameters control the processing of the pixel data before it is placed into
			client memory. These parameters are set with three commands: <function moreinfo="refentry">glPixelStore</function>,
			<function moreinfo="refentry">glPixelTransfer</function>, and <function moreinfo="refentry">glPixelMap</function>. This
			reference page describes the effects on <function>glReadPixels</function> of most, but not all of the parameters
			specified by these three commands.
		</para>
		<para>
			When the <constant>GL_ARB_imaging</constant> extension is supported, the pixel data may be processed by additional
			operations including color table lookup, color matrix tranformations, convolutions, histograms and minimum and maximun
			pixel value computations.
		</para>
		<para>
			<function>glReadPixels</function> returns values from each pixel with lower left corner at (<parameter>x</parameter> +
			<inlineequation>
				<mml:math>
					<mml:mi>i</mml:mi>
				</mml:math>
			</inlineequation>, <parameter>y</parameter> + <inlineequation>
				<mml:math>
					<mml:mi>j</mml:mi>
				</mml:math>
			</inlineequation>) for 0 &le; <inlineequation>
				<mml:math>
					<mml:mi>i</mml:mi>
				</mml:math>
			</inlineequation> &lt; <parameter>width</parameter> and 0 &le; <inlineequation>
				<mml:math>
					<mml:mi>j</mml:mi>
				</mml:math>
			</inlineequation> &lt; <parameter>height</parameter>. This pixel is said to be the <inlineequation>
				<mml:math>
					<mml:mi>i</mml:mi>
				</mml:math>
			</inlineequation>th pixel in the <inlineequation>
				<mml:math>
					<mml:mi>j</mml:mi>
				</mml:math>
			</inlineequation>th row. Pixels are returned in row order from the lowest to the highest row, left to right in each row.
		</para>
		<para>
			<parameter>format</parameter> specifies the for the returned pixel values; accepted values are:
		</para>
		<variablelist>
			<varlistentry>
				<term><constant>GL_COLOR_INDEX</constant></term>
				<listitem>
					<simpara>
						Color indices are read from the color buffer selected by <function
						moreinfo="refentry">glReadBuffer</function>. Each index is converted to fixed point, shifted left or right
						depending on the value and sign of <constant>GL_INDEX_SHIFT</constant>, and added to
						<constant>GL_INDEX_OFFSET</constant>. If <constant>GL_MAP_COLOR</constant> is <constant>GL_TRUE</constant>,
						indices are replaced by their mappings in the table <constant>GL_PIXEL_MAP_I_TO_I</constant>.
					</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><constant>GL_STENCIL_INDEX</constant></term>
				<listitem>
					<simpara>
						Stencil values are read from the stencil buffer. Each index is converted to fixed point, shifted left or
						right depending on the value and sign of <constant>GL_INDEX_SHIFT</constant>, and added to
						<constant>GL_INDEX_OFFSET</constant>. If <constant>GL_MAP_STENCIL</constant> is
						<constant>GL_TRUE</constant>, indices are replaced by their mappings in the table
						<constant>GL_PIXEL_MAP_S_TO_S</constant>.
					</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><constant>GL_DEPTH_COMPONENT</constant></term>
				<listitem>
					<simpara>
						Depth values are read from the depth buffer. Each component is converted to floating point such that the
						minimum depth value maps to 0 and the maximum value maps to 1. Each component is then multiplied by
						<constant>GL_DEPTH_SCALE</constant>, added to <constant>GL_DEPTH_BIAS</constant>, and finally clamped to
						the range [0,1].
					</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><constant>GL_GREEN</constant></term>
				<term><constant>GL_BLUE</constant></term>
				<term><constant>GL_ALPHA</constant></term>
				<term><constant>GL_RGB</constant></term>
				<term><constant>GL_BGR</constant></term>
				<term><constant>GL_RGBA</constant></term>
				<term><constant>GL_BGRA</constant></term>
				<term><constant>GL_LUMINANCE</constant></term>
				<term><constant>GL_LUMINANCE_ALPHA</constant></term>
				<term><constant>GL_RED</constant></term>
				<listitem>
					<simpara>
						Processing differs depending on whether color buffers store color indices or RGBA color components. If
						color indices are stored, they are read from the color buffer selected by <function
						moreinfo="refentry">glReadBuffer</function>. Each index is converted to fixed point, shifted left or right
						depending on the value and sign of <constant>GL_INDEX_SHIFT</constant>, and added to
						<constant>GL_INDEX_OFFSET</constant>. Indices are then replaced by the red, green, blue, and alpha values
						obtained by indexing the tables <constant>GL_PIXEL_MAP_I_TO_R</constant>,
						<constant>GL_PIXEL_MAP_I_TO_G</constant>, <constant>GL_PIXEL_MAP_I_TO_B</constant>, and
						<constant>GL_PIXEL_MAP_I_TO_A</constant>. Each table must be of size <inlineequation>
							<mml:math>
								<mml:msup>
									<mml:mn>2</mml:mn>
									<mml:mi>n</mml:mi>
								</mml:msup>
							</mml:math>
						</inlineequation>, but <inlineequation>
							<mml:math>
								<mml:mi>n</mml:mi>
							</mml:math>
						</inlineequation> may be different for different tables. Before an index is used to look up a value in a
						table of size <inlineequation>
							<mml:math>
								<mml:msup>
									<mml:mn>2</mml:mn>
									<mml:mi>n</mml:mi>
								</mml:msup>
							</mml:math>
						</inlineequation>, it must be masked against <inlineequation>
							<mml:math>
								<mml:mrow>
									<mml:msup>
										<mml:mn>2</mml:mn>
										<mml:mi>n</mml:mi>
									</mml:msup>
									<mml:mo>-</mml:mo>
									<mml:mn>1</mml:mn>
								</mml:mrow>
							</mml:math>
						</inlineequation>.
					</simpara>
					<simpara>
						If RGBA color components are stored in the color buffers, they are read from the color buffer selected by
						<function moreinfo="refentry">glReadBuffer</function>. Each color component is converted to floating point
						such that zero intensity maps to 0.0 and full intensity maps to 1.0. Each component is then multiplied by
						<constant>GL_c_SCALE</constant> and added to <constant>GL_c_BIAS</constant>, where <parameter>c</parameter>
						is RED, GREEN, BLUE, or ALPHA. Finally, if <constant>GL_MAP_COLOR</constant> is
						<constant>GL_TRUE</constant>, each component is clamped to the range [0,1], scaled to the size of its
						corresponding table, and is then replaced by its mapping in the table
						<constant>GL_PIXEL_MAP_c_TO_c</constant>, where <parameter>c</parameter> is R, G, B, or A.
					</simpara>
					<simpara>
						Unneeded data is then discarded. For example, <constant>GL_RED</constant> discards the green, blue, and
						alpha components, while <constant>GL_RGB</constant> discards only the alpha component.
						<constant>GL_LUMINANCE</constant> computes a single-component value as the sum of the red, green, and blue
						components, and <constant>GL_LUMINANCE_ALPHA</constant> does the same, while keeping alpha as a second
						value. The final values are clamped to the range [0,1].
					</simpara>
				</listitem>
			</varlistentry>
		</variablelist>
		<para>
			The shift, scale, bias, and lookup factors just described are all specified by
		</para>
		<para>
			<function moreinfo="refentry">glPixelTransfer</function>. The lookup table contents themselves are specified by
			<function moreinfo="refentry">glPixelMap</function>.
		</para>
		<para>
			Finally, the indices or components are converted to the proper , as specified by <parameter>type</parameter>. If
			<parameter>format</parameter> is <constant>GL_COLOR_INDEX</constant> or <constant>GL_STENCIL_INDEX</constant> and
			<parameter>type</parameter> is not <constant>GL_FLOAT</constant>, each index is masked with the mask value given in the
			following table. If <parameter>type</parameter> is <constant>GL_FLOAT</constant>, then each integer index is converted
			to single-precision floating-point .
		</para>
		<para>
			If <parameter>format</parameter> is <constant>GL_RED</constant>, <constant>GL_GREEN</constant>,
			<constant>GL_BLUE</constant>, <constant>GL_ALPHA</constant>, <constant>GL_RGB</constant>, <constant>GL_BGR</constant>,
			<constant>GL_RGBA</constant>, <constant>GL_BGRA</constant>, <constant>GL_LUMINANCE</constant>, or
			<constant>GL_LUMINANCE_ALPHA</constant> and <parameter>type</parameter> is not <constant>GL_FLOAT</constant>, each
			component is multiplied by the multiplier shown in the following table. If type is <constant>GL_FLOAT</constant>, then
			each component is passed as is (or converted to the client's single-precision floating-point if it is different from
			the one used by the GL).
		</para>
		<informaltable frame="topbot">
			<tgroup cols="3">
				<tbody>
					<row>
						<entry><parameter>type</parameter></entry>
						<entry align="center"><emphasis role="bold">index mask</emphasis></entry>
						<entry align="center"><emphasis role="bold">component conversion</emphasis></entry>
					</row>
					<row>
						<entry><constant>GL_UNSIGNED_BYTE</constant></entry>
						<entry align="center"><inlineequation>
							<mml:math>
								<mml:mrow>
									<mml:mn>2</mml:mn>
									<mml:mo>&Hat;</mml:mo>
									<mml:mn>8</mml:mn>
									<mml:mo>-</mml:mo>
									<mml:mn>1</mml:mn>
								</mml:mrow>
							</mml:math>
						</inlineequation></entry>
						<entry align="center"><inlineequation>
							<mml:math>
								<mml:mrow>
									<mml:mo>(</mml:mo>
									<mml:mn>2</mml:mn>
									<mml:mo>&Hat;</mml:mo>
									<mml:mn>8</mml:mn>
									<mml:mo>-</mml:mo>
									<mml:mn>1</mml:mn>
									<mml:mo>)</mml:mo>
									<mml:mi>c</mml:mi>
								</mml:mrow>
							</mml:math>
						</inlineequation></entry>
					</row>
					<row>
						<entry><constant>GL_BYTE</constant></entry>
						<entry align="center"><inlineequation>
							<mml:math>
								<mml:mrow>
									<mml:mn>2</mml:mn>
									<mml:mo>&Hat;</mml:mo>
									<mml:mn>7</mml:mn>
									<mml:mo>-</mml:mo>
									<mml:mn>1</mml:mn>
								</mml:mrow>
							</mml:math>
						</inlineequation></entry>
						<entry align="center"><inlineequation>
							<mml:math>
								<mml:mrow>
									<mml:mo>[</mml:mo>
									<mml:mo>(</mml:mo>
									<mml:mn>2</mml:mn>
									<mml:mo>&Hat;</mml:mo>
									<mml:mn>8</mml:mn>
									<mml:mo>-</mml:mo>
									<mml:mn>1</mml:mn>
									<mml:mo>)</mml:mo>
									<mml:mi>c</mml:mi>
									<mml:mo>-</mml:mo>
									<mml:mn>1</mml:mn>
									<mml:mo>]</mml:mo>
									<mml:mo>/</mml:mo>
									<mml:mn>2</mml:mn>
								</mml:mrow>
							</mml:math>
						</inlineequation></entry>
					</row>
					<row>
						<entry><constant>GL_BITMAP</constant></entry>
						<entry align="center"><inlineequation>
							<mml:math>
								<mml:mn>1</mml:mn>
							</mml:math>
						</inlineequation></entry>
						<entry align="center"><inlineequation>
							<mml:math>
								<mml:mn>1</mml:mn>
							</mml:math>
						</inlineequation></entry>
					</row>
					<row>
						<entry><constant>GL_UNSIGNED_SHORT</constant></entry>
						<entry align="center"><inlineequation>
							<mml:math>
								<mml:mrow>
									<mml:mn>2</mml:mn>
									<mml:mo>&Hat;</mml:mo>
									<mml:mn>16</mml:mn>
									<mml:mo>-</mml:mo>
									<mml:mn>1</mml:mn>
								</mml:mrow>
							</mml:math>
						</inlineequation></entry>
						<entry align="center"><inlineequation>
							<mml:math>
								<mml:mrow>
									<mml:mo>(</mml:mo>
									<mml:mn>2</mml:mn>
									<mml:mo>&Hat;</mml:mo>
									<mml:mn>16</mml:mn>
									<mml:mo>-</mml:mo>
									<mml:mn>1</mml:mn>
									<mml:mo>)</mml:mo>
									<mml:mi>c</mml:mi>
								</mml:mrow>
							</mml:math>
						</inlineequation></entry>
					</row>
					<row>
						<entry><constant>GL_SHORT</constant></entry>
						<entry align="center"><inlineequation>
							<mml:math>
								<mml:mrow>
									<mml:mn>2</mml:mn>
									<mml:mo>&Hat;</mml:mo>
									<mml:mn>15</mml:mn>
									<mml:mo>-</mml:mo>
									<mml:mn>1</mml:mn>
								</mml:mrow>
							</mml:math>
						</inlineequation></entry>
						<entry align="center"><inlineequation>
							<mml:math>
								<mml:mrow>
									<mml:mo>[</mml:mo>
									<mml:mo>(</mml:mo>
									<mml:mn>2</mml:mn>
									<mml:mo>&Hat;</mml:mo>
									<mml:mn>16</mml:mn>
									<mml:mo>-</mml:mo>
									<mml:mn>1</mml:mn>
									<mml:mo>)</mml:mo>
									<mml:mi>c</mml:mi>
									<mml:mo>-</mml:mo>
									<mml:mn>1</mml:mn>
									<mml:mo>]</mml:mo>
									<mml:mo>/</mml:mo>
									<mml:mn>2</mml:mn>
								</mml:mrow>
							</mml:math>
						</inlineequation></entry>
					</row>
					<row>
						<entry><constant>GL_UNSIGNED_INT</constant></entry>
						<entry align="center"><inlineequation>
							<mml:math>
								<mml:mrow>
									<mml:mn>2</mml:mn>
									<mml:mo>&Hat;</mml:mo>
									<mml:mn>32</mml:mn>
									<mml:mo>-</mml:mo>
									<mml:mn>1</mml:mn>
								</mml:mrow>
							</mml:math>
						</inlineequation></entry>
						<entry align="center"><inlineequation>
							<mml:math>
								<mml:mrow>
									<mml:mo>(</mml:mo>
									<mml:mn>2</mml:mn>
									<mml:mo>&Hat;</mml:mo>
									<mml:mn>32</mml:mn>
									<mml:mo>-</mml:mo>
									<mml:mn>1</mml:mn>
									<mml:mo>)</mml:mo>
									<mml:mi>c</mml:mi>
								</mml:mrow>
							</mml:math>
						</inlineequation></entry>
					</row>
					<row>
						<entry><constant>GL_INT</constant></entry>
						<entry align="center"><inlineequation>
							<mml:math>
								<mml:mrow>
									<mml:mn>2</mml:mn>
									<mml:mo>&Hat;</mml:mo>
									<mml:mn>31</mml:mn>
									<mml:mo>-</mml:mo>
									<mml:mn>1</mml:mn>
								</mml:mrow>
							</mml:math>
						</inlineequation></entry>
						<entry align="center"><inlineequation>
							<mml:math>
								<mml:mrow>
									<mml:mo>[</mml:mo>
									<mml:mo>(</mml:mo>
									<mml:mn>2</mml:mn>
									<mml:mo>&Hat;</mml:mo>
									<mml:mn>32</mml:mn>
									<mml:mo>-</mml:mo>
									<mml:mn>1</mml:mn>
									<mml:mo>)</mml:mo>
									<mml:mi>c</mml:mi>
									<mml:mo>-</mml:mo>
									<mml:mn>1</mml:mn>
									<mml:mo>]</mml:mo>
									<mml:mo>/</mml:mo>
									<mml:mn>2</mml:mn>
								</mml:mrow>
							</mml:math>
						</inlineequation></entry>
					</row>
					<row>
						<entry><constant>GL_FLOAT</constant></entry>
						<entry align="center">none</entry>
						<entry align="center"><inlineequation>
							<mml:math>
								<mml:mi>c</mml:mi>
							</mml:math>
						</inlineequation></entry>
					</row>
				</tbody>
			</tgroup>
		</informaltable>
		<para>
			Return values are placed in memory as follows. If <parameter>format</parameter> is <constant>GL_COLOR_INDEX</constant>,
			<constant>GL_STENCIL_INDEX</constant>, <constant>GL_DEPTH_COMPONENT</constant>, <constant>GL_RED</constant>,
			<constant>GL_GREEN</constant>, <constant>GL_BLUE</constant>, <constant>GL_ALPHA</constant>, or
			<constant>GL_LUMINANCE</constant>, a single value is returned and the data for the <inlineequation>
				<mml:math>
					<mml:mi>i</mml:mi>
				</mml:math>
			</inlineequation>th pixel in the <inlineequation>
				<mml:math>
					<mml:mi>j</mml:mi>
				</mml:math>
			</inlineequation>th row is placed in location <inlineequation>
				<mml:math>
					<mml:mrow>
						<mml:mo>(</mml:mo>
						<mml:mi>j</mml:mi>
						<mml:mo>)</mml:mo>
						<mml:mi>width</mml:mi>
						<mml:mo>+</mml:mo>
						<mml:mi>i</mml:mi>
					</mml:mrow>
				</mml:math>
			</inlineequation>. <constant>GL_RGB</constant> and <constant>GL_BGR</constant> return three values,
			<constant>GL_RGBA</constant> and <constant>GL_BGRA</constant> return four values, and
			<constant>GL_LUMINANCE_ALPHA</constant> returns two values for each pixel, with all values corresponding to a single
			pixel occupying contiguous space in <parameter>pixels</parameter>. Storage parameters set by <function
			moreinfo="refentry">glPixelStore</function>, such as <constant>GL_PACK_LSB_FIRST</constant> and
			<constant>GL_PACK_SWAP_BYTES</constant>, affect the way that data is written into memory. See <function
			moreinfo="refentry">glPixelStore</function> for a description.
		</para>
	</refsect1>
	<refsect1 id="glReadPixels.3G-notes">
		<title>Notes</title>
		<para>
			Values for pixels that lie outside the window connected to the current GL context are undefined.
		</para>
		<para>
			If an error is generated, no change is made to the contents of <parameter>pixels</parameter>.
		</para>
	</refsect1>
	<refsect1 id="glReadPixels.3G-errors">
		<title>Errors</title>
		<para>
			<constant>GL_INVALID_ENUM</constant> is generated if <parameter>format</parameter> or <parameter>type</parameter> is
			not an accepted value.
		</para>
		<para>
			<constant>GL_INVALID_ENUM</constant> is generated if <parameter>type</parameter> is <constant>GL_BITMAP</constant> and
			<parameter>format</parameter> is not <constant>GL_COLOR_INDEX</constant> or <constant>GL_STENCIL_INDEX</constant>.
		</para>
		<para>
			<constant>GL_INVALID_VALUE</constant> is generated if either <parameter>width</parameter> or
			<parameter>height</parameter> is negative.
		</para>
		<para>
			<constant>GL_INVALID_OPERATION</constant> is generated if <parameter>format</parameter> is
			<constant>GL_COLOR_INDEX</constant> and the color buffers store RGBA color components.
		</para>
		<para>
			<constant>GL_INVALID_OPERATION</constant> is generated if <parameter>format</parameter> is
			<constant>GL_STENCIL_INDEX</constant> and there is no stencil buffer.
		</para>
		<para>
			<constant>GL_INVALID_OPERATION</constant> is generated if <parameter>format</parameter> is
			<constant>GL_DEPTH_COMPONENT</constant> and there is no depth buffer.
		</para>
		<para>
			<constant>GL_INVALID_OPERATION</constant> is generated if <function>glReadPixels</function> is executed between the
			execution of <function moreinfo="refentry">glBegin</function> and the corresponding execution of <function
			moreinfo="refentry">glEnd</function>.
		</para>
		<para>
			<constant>GL_INVALID_OPERATION</constant> is generated if <parameter>type</parameter> is one of
			<constant>GL_UNSIGNED_BYTE_3_3_2</constant>, <constant>GL_UNSIGNED_BYTE_2_3_3_REV</constant>,
			<constant>GL_UNSIGNED_SHORT_5_6_5</constant>, or <constant>GL_UNSIGNED_SHORT_5_6_5_REV</constant> and
			<parameter>format</parameter> is not <constant>GL_RGB</constant>.
		</para>
		<para>
			<constant>GL_INVALID_OPERATION</constant> is generated if <parameter>type</parameter> is one of
			<constant>GL_UNSIGNED_SHORT_4_4_4_4</constant>, <constant>GL_UNSIGNED_SHORT_4_4_4_4_REV</constant>,
			<constant>GL_UNSIGNED_SHORT_5_5_5_1</constant>, <constant>GL_UNSIGNED_SHORT_1_5_5_5_REV</constant>,
			<constant>GL_UNSIGNED_INT_8_8_8_8</constant>, <constant>GL_UNSIGNED_INT_8_8_8_8_REV</constant>,
			<constant>GL_UNSIGNED_INT_10_10_10_2</constant>, or <constant>GL_UNSIGNED_INT_2_10_10_10_REV</constant> and
			<parameter>format</parameter> is neither <constant>GL_RGBA</constant> nor <constant>GL_BGRA</constant>.
		</para>
		<para>
			The formats <constant>GL_BGR</constant>, and <constant>GL_BGRA</constant> and types
			<constant>GL_UNSIGNED_BYTE_3_3_2</constant>, <constant>GL_UNSIGNED_BYTE_2_3_3_REV</constant>,
			<constant>GL_UNSIGNED_SHORT_5_6_5</constant>, <constant>GL_UNSIGNED_SHORT_5_6_5_REV</constant>,
			<constant>GL_UNSIGNED_SHORT_4_4_4_4</constant>, <constant>GL_UNSIGNED_SHORT_4_4_4_4_REV</constant>,
			<constant>GL_UNSIGNED_SHORT_5_5_5_1</constant>, <constant>GL_UNSIGNED_SHORT_1_5_5_5_REV</constant>,
			<constant>GL_UNSIGNED_INT_8_8_8_8</constant>, <constant>GL_UNSIGNED_INT_8_8_8_8_REV</constant>,
			<constant>GL_UNSIGNED_INT_10_10_10_2</constant>, and <constant>GL_UNSIGNED_INT_2_10_10_10_REV</constant> are available
			only if the GL version is 1.2 or greater.
		</para>
	</refsect1>
	<refsect1 id="glReadPixels.3G-associated_gets">
		<title>Associated Gets</title>
		<para>
			<function moreinfo="refentry">glGet</function> with argument <constant>GL_INDEX_MODE</constant>
		</para>
	</refsect1>
	<refsect1 id="glReadPixels.3G-see_also">
		<title>See Also</title>
		<para>
			<simplelist type="inline">
				<member><citerefentry>
					<refentrytitle>glCopyPixels</refentrytitle>
					<manvolnum>3G</manvolnum>
				</citerefentry></member>
				<member><citerefentry>
					<refentrytitle>glDrawPixels</refentrytitle>
					<manvolnum>3G</manvolnum>
				</citerefentry></member>
				<member><citerefentry>
					<refentrytitle>glPixelMap</refentrytitle>
					<manvolnum>3G</manvolnum>
				</citerefentry></member>
				<member><citerefentry>
					<refentrytitle>glPixelStore</refentrytitle>
					<manvolnum>3G</manvolnum>
				</citerefentry></member>
				<member><citerefentry>
					<refentrytitle>glPixelTransfer</refentrytitle>
					<manvolnum>3G</manvolnum>
				</citerefentry></member>
				<member><citerefentry>
					<refentrytitle>glReadBuffer</refentrytitle>
					<manvolnum>3G</manvolnum>
				</citerefentry></member>
			</simplelist>
		</para>
	</refsect1>
</refentry>
