<refentry id="glEvalMesh.3G">
	<refmeta id="glEvalMesh.3G-meta">
		<refentrytitle>glEvalMesh</refentrytitle>
		<manvolnum>3G</manvolnum>
	</refmeta>
	<refnamediv id="glEvalMesh.3G-name">
		<refname>glEvalMesh1</refname>
		<refname>glEvalMesh2</refname>
		<refpurpose>compute a one- or two-dimensional grid of points or lines</refpurpose>
	</refnamediv>
	<refsynopsisdiv id="glEvalMesh.3G-c_spec-1">
		<title>C Specification</title>
		<funcsynopsis>
			<funcprototype>
				<funcdef>void&nbsp;<function>glEvalMesh1</function></funcdef>
				<paramdef>GLenum&nbsp;<parameter>mode</parameter></paramdef>
				<paramdef>GLint&nbsp;<parameter>i1</parameter></paramdef>
				<paramdef>GLint&nbsp;<parameter>i2</parameter></paramdef>
			</funcprototype>
		</funcsynopsis>
	</refsynopsisdiv>
	<refsect1 id="glEvalMesh.3G-parameters-1">
		<title>Parameters</title>
		<variablelist>
			<varlistentry>
				<term><parameter>mode</parameter></term>
				<listitem>
					<simpara>
						In <function>glEvalMesh1</function>, specifies whether to compute a one-dimensional mesh of points or
						lines. Symbolic constants <constant>GL_POINT</constant> and <constant>GL_LINE</constant> are accepted.
					</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><parameter>i1</parameter>, <parameter>i2</parameter></term>
				<listitem>
					<simpara>
						Specify the first and last integer values for grid domain variable <inlineequation>
							<mml:math>
								<mml:mi>i</mml:mi>
							</mml:math>
						</inlineequation>.
					</simpara>
				</listitem>
			</varlistentry>
		</variablelist>
	</refsect1>
	<refsect1 id="glEvalMesh.3G-c_spec-2">
		<title>C Specification</title>
		<para>
			void <function>glEvalMesh2</function>( GLenum <parameter>mode</parameter>, GLint <parameter>i1</parameter>, GLint
			<parameter>i2</parameter>, GLint <parameter>j1</parameter>, GLint <parameter>j2</parameter> )
		</para>
	</refsect1>
	<refsect1 id="glEvalMesh.3G-parameters-2">
		<title>Parameters</title>
		<variablelist>
			<varlistentry>
				<term><parameter>mode</parameter></term>
				<listitem>
					<simpara>
						In <function>glEvalMesh2</function>, specifies whether to compute a two-dimensional mesh of points, lines,
						or polygons. Symbolic constants <constant>GL_POINT</constant>, <constant>GL_LINE</constant>, and
						<constant>GL_FILL</constant> are accepted.
					</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><parameter>i1</parameter>, <parameter>i2</parameter></term>
				<listitem>
					<simpara>
						Specify the first and last integer values for grid domain variable <inlineequation>
							<mml:math>
								<mml:mi>i</mml:mi>
							</mml:math>
						</inlineequation>.
					</simpara>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><parameter>j1</parameter>, <parameter>j2</parameter></term>
				<listitem>
					<simpara>
						Specify the first and last integer values for grid domain variable <inlineequation>
							<mml:math>
								<mml:mi>j</mml:mi>
							</mml:math>
						</inlineequation>.
					</simpara>
				</listitem>
			</varlistentry>
		</variablelist>
	</refsect1>
	<refsect1 id="glEvalMesh.3G-description">
		<title>Description</title>
		<para>
			<function moreinfo="refentry">glMapGrid</function> and <function moreinfo="refentry">glEvalMesh</function> are used in
			tandem to efficiently generate and evaluate a series of evenly-spaced map domain values. <function
			moreinfo="refentry">glEvalMesh</function> steps through the integer domain of a one- or two-dimensional grid, whose
			range is the domain of the evaluation maps specified by <function moreinfo="refentry">glMap1</function> and <function
			moreinfo="refentry">glMap2</function>. <parameter>mode</parameter> determines whether the resulting vertices are
			connected as points, lines, or filled polygons.
		</para>
		<para>
			In the one-dimensional case, <function>glEvalMesh1</function>, the mesh is generated as if the following code fragment
			were executed:
		</para>
		<programlisting>glBegin( type );
for ( i = i1; i &lt;= i2; i += 1 )
    glEvalCoord1( i*delta_u + u1 );
glEnd();</programlisting>
		<para>
			where
		</para>
		<informalequation>
			<mml:math>
				<mml:mi>delta_u</mml:mi>
				<mml:mo>=</mml:mo>
				<mml:mfrac>
					<mml:mfenced>
						<mml:mrow>
							<mml:mi>u2</mml:mi>
							<mml:mo>-</mml:mo>
							<mml:mi>u1</mml:mi>
						</mml:mrow>
					</mml:mfenced>
					<mml:mi>n</mml:mi>
				</mml:mfrac>
			</mml:math>
		</informalequation>
		<para>
			and <parameter>n</parameter>, <parameter>u1</parameter>, and <parameter>u2</parameter> are the arguments to the most
			recent <function moreinfo="refentry">glMapGrid1</function> command. <parameter>type</parameter> is
			<constant>GL_POINTS</constant> if <parameter>mode</parameter> is <constant>GL_POINT</constant>, or
			<constant>GL_LINES</constant> if <parameter>mode</parameter> is <constant>GL_LINE</constant>.
		</para>
		<para>
			The one absolute numeric requirement is that if <inlineequation>
				<mml:math>
					<mml:mi>i</mml:mi>
					<mml:mo>=</mml:mo>
					<mml:mi>n</mml:mi>
				</mml:math>
			</inlineequation>, then the value computed from <inlineequation>
				<mml:math>
					<mml:mi>i</mml:mi>
					<mml:mo>&CenterDot;</mml:mo>
					<mml:mi>&Delta;</mml:mi>
					<mml:mi>u</mml:mi>
					<mml:mo>+</mml:mo>
					<mml:msub>
						<mml:mi>u</mml:mi>
						<mml:mn>1</mml:mn>
					</mml:msub>
				</mml:math>
			</inlineequation> is exactly <inlineequation>
				<mml:math>
					<mml:msub>
						<mml:mi>u</mml:mi>
						<mml:mn>2</mml:mn>
					</mml:msub>
				</mml:math>
			</inlineequation>.
		</para>
		<para>
			In the two-dimensional case, <function>glEvalMesh2</function>, let
		</para>
		<para>
			<inlineequation>
				<mml:math>
					<mml:mrow>
						<mml:mi>&Delta;</mml:mi>
						<mml:mi>u</mml:mi>
						<mml:mo>=</mml:mo>
						<mml:mo>(</mml:mo>
						<mml:msub>
							<mml:mi>u</mml:mi>
							<mml:mn>2</mml:mn>
						</mml:msub>
						<mml:mo>-</mml:mo>
						<mml:msub>
							<mml:mi>u</mml:mi>
							<mml:mn>1</mml:mn>
						</mml:msub>
						<mml:mo>)</mml:mo>
						<mml:mo>/</mml:mo>
						<mml:mi>n</mml:mi>
					</mml:mrow>
				</mml:math>
			</inlineequation> <inlineequation>
				<mml:math>
					<mml:mrow>
						<mml:mi>&Delta;</mml:mi>
						<mml:mi>v</mml:mi>
						<mml:mo>=</mml:mo>
						<mml:mo>(</mml:mo>
						<mml:msub>
							<mml:mi>v</mml:mi>
							<mml:mn>2</mml:mn>
						</mml:msub>
						<mml:mo>-</mml:mo>
						<mml:msub>
							<mml:mi>v</mml:mi>
							<mml:mn>1</mml:mn>
						</mml:msub>
						<mml:mo>)</mml:mo>
						<mml:mo>/</mml:mo>
						<mml:mi>m</mml:mi>
					</mml:mrow>
				</mml:math>
			</inlineequation>,
		</para>
		<para>
			where <inlineequation>
				<mml:math>
					<mml:mi>n</mml:mi>
				</mml:math>
			</inlineequation>, <inlineequation>
				<mml:math>
					<mml:msub>
						<mml:mi>u</mml:mi>
						<mml:mn>1</mml:mn>
					</mml:msub>
				</mml:math>
			</inlineequation>, <inlineequation>
				<mml:math>
					<mml:msub>
						<mml:mi>u</mml:mi>
						<mml:mn>2</mml:mn>
					</mml:msub>
				</mml:math>
			</inlineequation>, <inlineequation>
				<mml:math>
					<mml:mi>m</mml:mi>
				</mml:math>
			</inlineequation>, <inlineequation>
				<mml:math>
					<mml:msub>
						<mml:mi>v</mml:mi>
						<mml:mn>1</mml:mn>
					</mml:msub>
				</mml:math>
			</inlineequation>, and <inlineequation>
				<mml:math>
					<mml:msub>
						<mml:mi>v</mml:mi>
						<mml:mn>2</mml:mn>
					</mml:msub>
				</mml:math>
			</inlineequation> are the arguments to the most recent <function moreinfo="refentry">glMapGrid2</function> command.
			Then, if <parameter>mode</parameter> is <constant>GL_FILL</constant>, the <function>glEvalMesh2</function> command is
			equivalent to:
		</para>
		<para>
			for ( j = <parameter>j1</parameter>; j &lt; <parameter>j2</parameter>; j += 1 ) { glBegin( GL_QUAD_STRIP ); for ( i =
			<parameter>i1</parameter>; i &lt;= <parameter>i2</parameter>; i += 1 ) { glEvalCoord2( i<inlineequation>
				<mml:math>
					<mml:mrow>
						<mml:mo>&CenterDot;</mml:mo>
						<mml:mi>&Delta;</mml:mi>
						<mml:mi>u</mml:mi>
						<mml:mo>+</mml:mo>
						<mml:msub>
							<mml:mi>u</mml:mi>
							<mml:mn>1</mml:mn>
						</mml:msub>
					</mml:mrow>
				</mml:math>
			</inlineequation>, j<inlineequation>
				<mml:math>
					<mml:mrow>
						<mml:mo>&CenterDot;</mml:mo>
						<mml:mi>&Delta;</mml:mi>
						<mml:mi>v</mml:mi>
						<mml:mo>+</mml:mo>
						<mml:msub>
							<mml:mi>v</mml:mi>
							<mml:mn>1</mml:mn>
						</mml:msub>
					</mml:mrow>
				</mml:math>
			</inlineequation> ); glEvalCoord2( i<inlineequation>
				<mml:math>
					<mml:mrow>
						<mml:mo>&CenterDot;</mml:mo>
						<mml:mi>&Delta;</mml:mi>
						<mml:mi>u</mml:mi>
						<mml:mo>+</mml:mo>
						<mml:msub>
							<mml:mi>u</mml:mi>
							<mml:mn>1</mml:mn>
						</mml:msub>
					</mml:mrow>
				</mml:math>
			</inlineequation>, (j+1)<inlineequation>
				<mml:math>
					<mml:mrow>
						<mml:mo>&CenterDot;</mml:mo>
						<mml:mi>&Delta;</mml:mi>
						<mml:mi>v</mml:mi>
						<mml:mo>+</mml:mo>
						<mml:msub>
							<mml:mi>v</mml:mi>
							<mml:mn>1</mml:mn>
						</mml:msub>
					</mml:mrow>
				</mml:math>
			</inlineequation> ); } glEnd(); }
		</para>
		<para>
			If <parameter>mode</parameter> is <constant>GL_LINE</constant>, then a call to <function>glEvalMesh2</function> is
			equivalent to:
		</para>
		<para>
			for ( j = <parameter>j1</parameter>; j &lt;= <parameter>j2</parameter>; j += 1 ) { glBegin( GL_LINE_STRIP ); for ( i =
			<parameter>i1</parameter>; i &lt;= <parameter>i2</parameter>; i += 1 ) glEvalCoord2( i<inlineequation>
				<mml:math>
					<mml:mrow>
						<mml:mo>&CenterDot;</mml:mo>
						<mml:mi>&Delta;</mml:mi>
						<mml:mi>u</mml:mi>
						<mml:mo>+</mml:mo>
						<mml:msub>
							<mml:mi>u</mml:mi>
							<mml:mn>1</mml:mn>
						</mml:msub>
					</mml:mrow>
				</mml:math>
			</inlineequation>, j<inlineequation>
				<mml:math>
					<mml:mrow>
						<mml:mo>&CenterDot;</mml:mo>
						<mml:mi>&Delta;</mml:mi>
						<mml:mi>v</mml:mi>
						<mml:mo>+</mml:mo>
						<mml:msub>
							<mml:mi>v</mml:mi>
							<mml:mn>1</mml:mn>
						</mml:msub>
					</mml:mrow>
				</mml:math>
			</inlineequation> ); glEnd(); } for ( i = <parameter>i1</parameter>; i &lt;= <parameter>i2</parameter>; i += 1 ) {
			glBegin( GL_LINE_STRIP ); for ( j = <parameter>j1</parameter>; j &lt;= <parameter>j1</parameter>; j += 1 )
			glEvalCoord2( i<inlineequation>
				<mml:math>
					<mml:mrow>
						<mml:mo>&CenterDot;</mml:mo>
						<mml:mi>&Delta;</mml:mi>
						<mml:mi>u</mml:mi>
						<mml:mo>+</mml:mo>
						<mml:msub>
							<mml:mi>u</mml:mi>
							<mml:mn>1</mml:mn>
						</mml:msub>
					</mml:mrow>
				</mml:math>
			</inlineequation>, j<inlineequation>
				<mml:math>
					<mml:mrow>
						<mml:mo>&CenterDot;</mml:mo>
						<mml:mi>&Delta;</mml:mi>
						<mml:mi>v</mml:mi>
						<mml:mo>+</mml:mo>
						<mml:msub>
							<mml:mi>v</mml:mi>
							<mml:mn>1</mml:mn>
						</mml:msub>
					</mml:mrow>
				</mml:math>
			</inlineequation> ); glEnd(); }
		</para>
		<para>
			And finally, if <parameter>mode</parameter> is <constant>GL_POINT</constant>, then a call to
			<function>glEvalMesh2</function> is equivalent to:
		</para>
		<para>
			glBegin( GL_POINTS ); for ( j = <parameter>j1</parameter>; j &lt;= <parameter>j2</parameter>; j += 1 ) for ( i =
			<parameter>i1</parameter>; i &lt;= <parameter>i2</parameter>; i += 1 ) glEvalCoord2( i<inlineequation>
				<mml:math>
					<mml:mrow>
						<mml:mo>&CenterDot;</mml:mo>
						<mml:mi>&Delta;</mml:mi>
						<mml:mi>u</mml:mi>
						<mml:mo>+</mml:mo>
						<mml:msub>
							<mml:mi>u</mml:mi>
							<mml:mn>1</mml:mn>
						</mml:msub>
					</mml:mrow>
				</mml:math>
			</inlineequation>, j<inlineequation>
				<mml:math>
					<mml:mrow>
						<mml:mo>&CenterDot;</mml:mo>
						<mml:mi>&Delta;</mml:mi>
						<mml:mi>v</mml:mi>
						<mml:mo>+</mml:mo>
						<mml:msub>
							<mml:mi>v</mml:mi>
							<mml:mn>1</mml:mn>
						</mml:msub>
					</mml:mrow>
				</mml:math>
			</inlineequation> ); glEnd();
		</para>
		<para>
			In all three cases, the only absolute numeric requirements are that if <inlineequation>
				<mml:math>
					<mml:mrow>
						<mml:mi>i</mml:mi>
						<mml:mo>=</mml:mo>
						<mml:mi>n</mml:mi>
					</mml:mrow>
				</mml:math>
			</inlineequation>, then the value computed from <inlineequation>
				<mml:math>
					<mml:mrow>
						<mml:mi>i</mml:mi>
						<mml:mo>&CenterDot;</mml:mo>
						<mml:mi>&Delta;</mml:mi>
						<mml:mi>u</mml:mi>
						<mml:mo>+</mml:mo>
						<mml:msub>
							<mml:mi>u</mml:mi>
							<mml:mn>1</mml:mn>
						</mml:msub>
					</mml:mrow>
				</mml:math>
			</inlineequation> is exactly <inlineequation>
				<mml:math>
					<mml:msub>
						<mml:mi>u</mml:mi>
						<mml:mn>2</mml:mn>
					</mml:msub>
				</mml:math>
			</inlineequation>, and if <inlineequation>
				<mml:math>
					<mml:mrow>
						<mml:mi>j</mml:mi>
						<mml:mo>=</mml:mo>
						<mml:mi>m</mml:mi>
					</mml:mrow>
				</mml:math>
			</inlineequation>, then the value computed from <inlineequation>
				<mml:math>
					<mml:mrow>
						<mml:mi>j</mml:mi>
						<mml:mo>&CenterDot;</mml:mo>
						<mml:mi>&Delta;</mml:mi>
						<mml:mi>v</mml:mi>
						<mml:mo>+</mml:mo>
						<mml:msub>
							<mml:mi>v</mml:mi>
							<mml:mn>1</mml:mn>
						</mml:msub>
					</mml:mrow>
				</mml:math>
			</inlineequation> is exactly <inlineequation>
				<mml:math>
					<mml:msub>
						<mml:mi>v</mml:mi>
						<mml:mn>2</mml:mn>
					</mml:msub>
				</mml:math>
			</inlineequation>.
		</para>
	</refsect1>
	<refsect1 id="glEvalMesh.3G-errors">
		<title>Errors</title>
		<para>
			<constant>GL_INVALID_ENUM</constant> is generated if <parameter>mode</parameter> is not an accepted value.
		</para>
		<para>
			<constant>GL_INVALID_OPERATION</constant> is generated if <function moreinfo="refentry">glEvalMesh</function> is
			executed between the execution of <function moreinfo="refentry">glBegin</function> and the corresponding execution of
			<function moreinfo="refentry">glEnd</function>.
		</para>
	</refsect1>
	<refsect1 id="glEvalMesh.3G-associated_gets">
		<title>Associated Gets</title>
		<para>
			<function moreinfo="refentry">glGet</function> with argument <constant>GL_MAP1_GRID_DOMAIN</constant>
		</para>
		<para>
			<function moreinfo="refentry">glGet</function> with argument <constant>GL_MAP2_GRID_DOMAIN</constant>
		</para>
		<para>
			<function moreinfo="refentry">glGet</function> with argument <constant>GL_MAP1_GRID_SEGMENTS</constant>
		</para>
		<para>
			<function moreinfo="refentry">glGet</function> with argument <constant>GL_MAP2_GRID_SEGMENTS</constant>
		</para>
	</refsect1>
	<refsect1 id="glEvalMesh.3G-see_also">
		<title>See Also</title>
		<para>
			<simplelist type="inline">
				<member><citerefentry>
					<refentrytitle>glBegin</refentrytitle>
					<manvolnum>3G</manvolnum>
				</citerefentry></member>
				<member><citerefentry>
					<refentrytitle>glEvalCoord</refentrytitle>
					<manvolnum>3G</manvolnum>
				</citerefentry></member>
				<member><citerefentry>
					<refentrytitle>glEvalPoint</refentrytitle>
					<manvolnum>3G</manvolnum>
				</citerefentry></member>
				<member><citerefentry>
					<refentrytitle>glMap1</refentrytitle>
					<manvolnum>3G</manvolnum>
				</citerefentry></member>
				<member><citerefentry>
					<refentrytitle>glMap2</refentrytitle>
					<manvolnum>3G</manvolnum>
				</citerefentry></member>
				<member><citerefentry>
					<refentrytitle>glMapGrid</refentrytitle>
					<manvolnum>3G</manvolnum>
				</citerefentry></member>
			</simplelist>
		</para>
	</refsect1>
</refentry>
